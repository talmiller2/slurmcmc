import json
import logging
import os
import pickle
import shutil

import numpy as np


def set_logging(work_dir=None, log_file=None):
    if log_file is not None:
        # create save directory and log file
        os.makedirs(work_dir, exist_ok=True)
        log_file_path = work_dir + '/' + log_file

        # basic logging definition
        logger = logging.getLogger()
        logger.setLevel(logging.INFO)

        # remove any previously defined loggers
        for handler in logger.handlers[:]:
            logger.removeHandler(handler)

        # print log messages to a log file
        fh = logging.FileHandler(log_file_path)
        fh_formatter = logging.Formatter(fmt='%(asctime)s %(message)s', datefmt='%d-%m-%Y %H:%M:%S')
        fh.setFormatter(fh_formatter)
        fh.setLevel(logging.INFO)
        logger.addHandler(fh)

        # print log messages to the console/termnal
        ch = logging.StreamHandler()
        ch_formatter = logging.Formatter('%(message)s')
        ch.setFormatter(ch_formatter)
        ch.setLevel(logging.INFO)
        logger.addHandler(ch)

        logging.info('setting log_file: ' + log_file_path)
    else:
        # print log messages to the console/terminal only
        logging.basicConfig(format='%(message)s', level=logging.DEBUG)

        # disable the warnings generated by matplotlib when in interactive mode
        logging.getLogger('matplotlib').setLevel(logging.ERROR)

    # disable the warnings generated by submitit
    logging.getLogger("submitit").setLevel(logging.ERROR)

    return


def save_restart_file(status, work_dir, restart_file):
    os.makedirs(work_dir, exist_ok=True)
    with open(work_dir + '/' + restart_file, 'wb') as f:
        pickle.dump(status, f)


def load_restart_file(work_dir, restart_file):
    restart_file_path = work_dir + '/' + restart_file
    if os.path.exists(restart_file_path):
        with open(restart_file_path, 'rb') as f:
            status = pickle.load(f)
        return status
    else:
        err_msg = f'restart_file does not exists. restart_file_path={restart_file_path}'
        logging.error(err_msg)
        raise ValueError(err_msg)


def combine_args(arg, extra_arg=None):
    args = [arg]
    if extra_arg is not None:
        args += [extra_arg]
    return args


def save_extra_arg_to_file(work_dir, extra_arg):
    # save the extra_arg in the run folder to document the full input used for this point
    if extra_arg is not None:
        extra_arg_file = work_dir + '/extra_arg.txt'
        with open(extra_arg_file, 'w') as json_file:
            json.dump(extra_arg, json_file)


def delete_directory(dir_path):
    if os.path.isdir(dir_path):
        shutil.rmtree(dir_path, ignore_errors=True)


def list_directories(path):
    return [d for d in os.listdir(path) if os.path.isdir(os.path.join(path, d))]


def point_to_tuple(point):
    # convert to tuple even in case of 1d point
    return tuple(point) if isinstance(point, (list, set, np.ndarray)) else (point,)


def calc_dimension(point):
    if isinstance(point, (int, float, type(None))):
        return 1
    elif isinstance(point, (list, np.ndarray)):
        return len(point)
    else:
        err_msg = f"Unsupported type for point={point}"
        logging.error(err_msg)
        raise TypeError(err_msg)
